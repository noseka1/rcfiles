% kub

# List Kubernetes events sorted by time
oc get events --sort-by metadata.creationTimestamp

# Watch Kubernetes events in all namespaces
oc get events --all-namespaces --sort-by metadata.creationTimestamp --watch

# List ALL Kubernetes resources in the current namespace (unsorted)
kubectl api-resources \
  --verbs=list \
  --namespaced \
  -o name \
  2>/dev/null | \
  grep -v events.events.k8s.io | \
  grep -v events | \
  grep -v packagemanifests.packages.operators.coreos.com | \
  xargs -n 1 \
    kubectl get \
      --show-kind \
      --ignore-not-found \
      --no-headers \
      2>/dev/null

# List ALL Kubernetes resources in the current namespace (sorted by creationTimestamp)
kubectl api-resources \
  --verbs=list \
  --namespaced \
  -o name \
  2>/dev/null | \
  grep -v events.events.k8s.io | \
  grep -v events | \
  grep -v packagemanifests.packages.operators.coreos.com | \
  grep -v pods.metrics.k8s.io | \
  while read resource; do
    echo "{\"resource\": \"$resource\"}"
    kubectl get --output json $resource 2>/dev/null
  done | jq --slurp --raw-output '. | to_entries | reduce .[] as $item (null; if $item.key % 2 == 0 then . + [ $item ] else .[-1].value += {"items": [ .[-1].value.resource as $res | $item.value.items[].metadata | { name: ($res + "/" + .name), ts: .creationTimestamp }]} end) | [ .[].value.items[] ] | sort_by(.ts) | .[] | .ts + " " + .name '

# Remove finalizers from ALL Kubernetes resources in the current namespace that were marked for deletion
kubectl api-resources --verbs=list --namespaced -o name 2>/dev/null | \
  grep -v events.events.k8s.io | \
  grep -v events | \
  grep -v packagemanifests.packages.operators.coreos.com | \
  xargs -n 1 \
    kubectl get \
      --show-kind \
      --ignore-not-found \
      --no-headers \
      --output custom-columns=KIND:.kind,NAME:.metadata.name,TIMESTAMP=:.metadata.deletionTimestamp | \
  grep -v 'none>' | \
  while read kind name timestamp; do
    kubectl patch $kind $name -p '{"metadata":{"finalizers":null}}' --type merge
  done

# Dump Kubernetes secrets in the current namespace to stdout
oc get secret --output name | while read SECRET; do echo "SECRET $SECRET"; oc extract $SECRET --to -; done 2>&1

# Dump Kubernetes configmaps in the current namespace to stdout
oc get configmap --output name | while read CM; do echo "CONFIGMAP $CM"; oc extract $CM --to -; done 2>&1

# Extract AWS cloud provider secrets from OCP
oc extract -n openshift-machine-api secret/aws-cloud-credentials --to -

# Decode Helm secret
oc extract -n <namespace> secret/<name> --to - 2>/dev/null  | base64 -d | gunzip | jq

# SSH into CodeReady Containers (CRC) virtual machine
ssh -i ~/.crc/machines/crc/id_ecdsa core@api.crc.testing

# Delete all CSVs
oc get csv \
  --all-namespaces \
  --output custom-columns=NAMESPACE:.metadata.namespace,NAME:.metadata.name \
  --no-headers | \
  grep 'openshift-pipelines-operator-rh.vx.y.z' | \
  while read ns name; do
    oc delete csv --namespace $ns $name
  done

# Print installed operator versions
oc get csv --all-namespaces --output custom-columns=NAME:.metadata.name --no-headers | sort | uniq

# Print available OLM operator default channels
oc get packagemanifest -o jsonpath='{range .items[*]}{.metadata.name} {.status.defaultChannel}{"\n"}{end}'

# Approve all pending CSRs in OpenShift
oc get csr -o json | \
  jq -r '.items[] | select(.status == {} ) | .metadata.name' | \
  xargs --no-run-if-empty oc adm certificate approve

# List Rook Ceph labels on nodes
oc get node -o json | \
  jq '[.items[] | { "name": .metadata.name, "labels": .metadata.labels | { "cluster.ocs.openshift.io/openshift-storage", "topology.kubernetes.io/region", "topology.kubernetes.io/zone", "topology.rook.io/datacenter", "topology.rook.io/room", "topology.rook.io/pod", "topology.rook.io/pdu", "topology.rook.io/row", "topology.rook.io/rack", "topology.rook.io/chassis" } | with_entries(select(.value)) }]'

# Delete all PVs belonging to a localvolumeset
oc delete pv -l storage.openshift.com/owner-kind=LocalVolumeSet,storage.openshift.com/owner-name=myvolumesetX

# Fix unexpected on-disk state by forcing machineconfig to overwrite the disk state
touch /run/machine-config-daemon-force

# Clean up non-running pods in Kubernetes
oc get po -A | grep -E '(CrashLoopBackOff|Error|ContainerStatusUnknown|ImagePullBackOff|Init:ContainerStatusUnknown|Completed)' | while read ns pod unused; do oc delete pod -n $ns $pod; done

# Clean up Kubernetes webhooks whose service has been removed
oc get validatingwebhookconfigurations.admissionregistration.k8s.io,mutatingwebhookconfigurations.admissionregistration.k8s.io -o json | jq --raw-output '.items[] | select(.webhooks[0].clientConfig.service != null) | "\(.kind) \(.metadata.name) \(.webhooks[0].clientConfig.service.namespace) \(.webhooks[0].clientConfig.service.name)"' | while read kind webhook namespace name; do oc get service -n $namespace $name 1>/dev/null 2>&1 || oc delete $kind $webhook; done

# List BMC addresses
oc get baremetalhosts.metal3.io -n openshift-machine-api -o custom-columns='NAME:.metadata.name,BMC Address:.spec.bmc.address'

# For each pod, list attached configMaps, secrets, and volumes
oc get pods -o json | jq '.items[] | { name: (.metadata.name), configMaps: [ .spec.volumes[] | select(has("configMap")) | .configMap.name ], secrets: [ .spec.volumes[] | select(has("secret")) | .secret.secretName ], volumes: [ .spec.volumes[] | select(has("persistentVolumeClaim")) | .persistentVolumeClaim.claimName ]} | del(.. | select(. == []))'

# For select pod, list container commands
oc get po <pod> -o json | jq '.spec.containers[] | { name, command, args }'

# Drain OpenShift node
oc adm drain <node> --force --ignore-daemonsets --delete-emptydir-data=false --disable-eviction=false --skip-wait-for-delete-timeout 0

# Display machine-config-controller logs
oc logs -n openshift-machine-config-operator deploy/machine-config-controller

# Display install-config.yaml of the running cluster
oc get cm -n kube-system cluster-config-v1 -o jsonpath='{.data.install-config}'

# Generate OpenShift installation image for agent-based installation
openshift-install agent create image --log-level debug --dir conf

% lin

# Jump into ODF tools pod
oc rsh --namespace openshift-storage deploy/rook-ceph-tools

# Download the TLS certificate from the remote server
openssl s_client -showcerts -servername <server_fqdn> -connect <server_fqdn>:443 </dev/null

# Sort installed RPMs by size
rpm -qa --queryformat '%{size} %{name}\\n' | sort -rn

# Fix file names
find . -maxdepth 1 -type f | \
  while read f; do
    f2=$(echo $f | tr -d ',' | tr -d "'" | tr ' ' '.')
    echo $f2
    mv "$f" "$f2"
  done

# Remove terminal color sequences from the log file, https://superuser.com/a/380778
sed 's/\\x1b\\[[0-9;]*m//g'

# Removes all "leaf" packages from the system that were originally installed as dependencies of user-installed packages, but which are no longer required by any such package
dnf autoremove

# Find all available package versions
dnf search --showduplicates <pkg_name>

# Register the system to the Red Hat Customer Portal and attach subscriptions
subscription-manager register && subscription-manager attach --pool 8a85f98460bfb0470160c2ff22f13e47

# Red Hat VPN
sudo openvpn --config /etc/openvpn/client/ovpn-rdu2-tcp.conf

# Log in to the OpenShift integrated registry
podman login -u xyz -p $(oc whoami -t) $(oc get route -n openshift-image-registry --no-headers --output custom-columns=HOSTNAME:.spec.host)

# Convert YouTube video to mp3
youtube-dl --extract-audio --audio-format mp3 <youtube_url>

# Update Debian packages
sudo apt update && sudo apt full-upgrade && sudo apt autoremove

# Break the CA bundle into individual cert files
awk 'BEGIN {c=0;} /BEGIN CERT/{c++} { print > "cert." c ".pem"}' < '<chain.pem>'

# Decode JWT token
echo <jwt_token> | jq -R 'gsub("-";"+") | gsub("_";"/") | split(".") | .[1] | @base64d | fromjson'

# Display X.509 certificate info
openssl x509 -text -in <cert.pem>

# Clean up stopped Podman containers and unused container images
podman container prune --force && podman image prune --all --force

# Push to quay.io
podman push --authfile ~/.mysecrets/docker/myquay.json

# Find executable files in the current directory + all subdirectories
find . -type f -print0 | xargs -0 -n 100 file | grep 'ELF.*executable'

# Find and replace text recursively
find . -type f -name '*' -print0 | xargs -0 sed -i 's#<foo>#<bar>#g'

# Split full album flac into a flac per track
shnsplit -f <file.cue> -t '%n - %t' -o flac <file.flac>

# Get all extended attributes of filesystem object
getfattr -d -m - <file>

# Check if SELinux is denying access
sealert -a /var/log/audit/audit.log

# Show nftables rules
sudo nft -j list ruleset | jq

# Flush firewall rules
sudo nft flush ruleset

# Show firewalld configuration
sudo firewall-cmd --list-all-zones

# Display X.509 certificate fingerprint
openssl x509 -noout -sha256 -fingerprint -in <cert.pem>

# Edit matching lines using Vim QuickFix (use :cnext, :cprev)
vi -q <(rg -H --no-heading --vimgrep EXPRESSION)

# Display detailed information on TCP connections
ss -tiepm

# Find duplicate files (https://unix.stackexchange.com/questions/277697/whats-the-quickest-way-to-find-duplicated-files)
find . ! -empty -type f -exec md5sum {} + | sort | uniq -w32 -dD

# Show volume (LUN) parameters
lsblk -po KNAME,TYPE,SIZE,VENDOR,MODEL,WWN

# Activate LVM devices
pvscan --cache --activate ay

# Grep through source code
rg -g '!vendor/' '<regular_expression>'

# Show available wifi networks
nmcli -f ALL dev wifi

# Measure response times using cURL (https://stackoverflow.com/questions/18215389/how-do-i-measure-request-and-response-times-at-once-using-curl)
curl -w '    time_namelookup:  %{time_namelookup}\n       time_connect:  %{time_connect}\n    time_appconnect:  %{time_appconnect}\n   time_pretransfer:  %{time_pretransfer}\n      time_redirect:  %{time_redirect}\n time_starttransfer:  %{time_starttransfer}\n                    ----------\n         time_total:  %{time_total}\n' -o /dev/null -s <URL>

% tcpdump

# List the network interfaces available on the system and on which tcpdump can capture packets
tcpdump -D

# Capture VLAN traffic
sudo tcpdump -i any -nn -vvv -e vlan

# Capture traffic. Print each packet in ASCII. Handy for capturing web pages
sudo tcpdump -i any -nn -vvv -A

# Search for git commit content i.e. actual lines of source code as opposed to commit messages
git rev-list --all | xargs git grep <regexp>

# More verbose lspci
lspci -nnk

# Drop caches, as well as reclaimable slab objects like dentries and inodes
free -h && sudo sync && echo 3 | sudo tee /proc/sys/vm/drop_caches >/dev/null && free -h
